/**

\defgroup Core Core
\{

\brief Interface definitions and utility functions for building models

Core contains the main structures for building and running models.
Most importantly, it defines the Model base interface every model needs to
implement in order to be used within Utopia.

\}

\defgroup Rules Rules on Entities
\{

\ingroup Core
\brief Algorithms for conveniently applying function objects on entities

## The General Idea
A rule is a function that computes the new state of the entity it is applied
to.

### Synchronous vs Asynchronous Updates

Applying a rule **synchronously** means that its result is applied to all
entities *simultaneously*. In practice, one uses a cache for storing the
intermediate states of the cells and then copies/moves the cache entries into
the respective cell states.

Applying a rule **asynchronously** means that its result for a single entity
is immediately imposed onto this entity. To avoid preferences in execution
order, users may choose to use shuffling before iterating over the cells.

## Implementation

A rule must be implemented by the programmer as a function (object).
The function it represents must take a pointer to the entity as single
argument and may capture arbitrary objects.
The function's return value is the new state of the entity it is applied to.

For asynchronously applied rules, no return value is required; the state may be
changed directly.

Currently, rules may also alter other members (i.e., tags) of the entity
they are applied to, and may even change states of other entities. *Notice
that this does not make sense if you intend to apply such a rule
synchronously!*

### Choosing Update Type When Calling `apply_rule`

Previously, the state cache for synchronous updates was implemented in the
entity itself. Therefore, users had to opt for *either* sync *or* async
updates when choosing the state data type. We now encourage the usage of
the Utopia::StateContainer with the specialization for the
Utopia::Update::manual tag (see
Utopia::StateContainer<StateType, Update::manual>).
This allows for choosing the update type via the Utopia::Update switch
directly when calling Utopia::apply_rule.

\code{.cc}
    using EntityTraits = Utopia::CellTraits<int, Utopia::Update::manual>;
    using CellManager = Utopia::CellManager<EntityTraits, MyModel>;

    CellManager cm = get_cm_from_somewhere();
    Utopia::apply_rule<Utopia::Update::async,
                       Utopia::Shuffle::off>(my_rule, cm.cells());
\endcode

\}



\defgroup Logging Output Logging
\{
\ingroup Core
\brief Utility functions for all logging output based on the spdlog backend.

All output of the simulation backend is intended to be controlled via
loggers. Loggers are implemented using spdlog
(see https://github.com/gabime/spdlog).
Regular output via the standard pipes `std::cout` and `std::cerr`
is strongly discouraged.

Utopia generates three types of loggers: One logger for Data I/O functions,
one for Core (backend) functions, and one for each model instance.
The Utopia::Model base class holds a logger instance which should be used
for information on the current model. To write log messages from within
Data I/O or Core backend functions, the respective logger first has to be
retrieved. This is achieved by using `spdlog::get`
(https://github.com/gabime/spdlog/wiki/2.-Creating-loggers#accessing-loggers-using-spdlogget).
The names for the two loggers are exported within the Utopia namespace.
All log levels are handled through the input configuration files.

The Utopia::PseudoParent automatically creates the utility loggers. For
executables without Models (like tests), the loggers have to be created
explicitly by manually calling Utopia::setup_loggers.
\}



\defgroup Model Model
\{
\ingroup Core
\brief The Model framework is the foundation for your future model.

By deriving from ::Utopia::Model, you have access to many infrastructure
features and can place your model into a hierarchy of models.
\}


\defgroup CellManager CellManager
\{
\ingroup Core
\brief An interface to build and use cellular automata

The ::Utopia::CellManager and associated constructs allow convenient use of
discretizations of physical space into rectangular, hexagonal, or triangular
grids.
\}

\defgroup AgentManager AgentManager
\{
\ingroup Core
\brief An interface for agent-based models
\}

\defgroup Entity Entity
\{
\ingroup Core
\brief The base class for managed entities, e.g. cells or agents.
\}

\defgroup Iter Iteration Utilities
\{
\ingroup Core
\brief Collection of classes and functions for custom iteration over ranges

This improves the standard C++ abilities to iterate over collections of
elements.

### Zip Function and Iterator

This implementation mirrors the Python `zip` function. It provides an iterator
over arbitrarily many heterogeneous collections. The Utopia::Itertools::zip
class stores references to the containers inserted into it and supplies
methods for retrieving the respective Utopia::Itertools::ZipIterator.

\code{.cc}
    #include <vector>
    #include <string>
    #include <utopia/core/zip.hh>

    constexpr size_t size = 10;
    std::vector<int> ints(size, 0);
    std::vector<double> doubles(size, 2.0);
    std::vector<std::string> strings(size, "A number:");

    auto range = Utopia::Itertools::zip(ints, doubles, strings);
\endcode

Zip iterators obey the C++ standard interface for iterators. They also adapt
their functionality on the lowest level iterator category of all containers
inserted into the object. For example, inserting an `std::vector` and an
`std::list` into Utopia::Itertools::zip will yield a bidirectional zip
iterator.

Dereferencing this iterator returns an `std::tuple` containing references
to the respective objects of the underlying containers. They can be captured
using structured bindings. Use `auto&` for capturing the references is not
necessary and might even be illegal in some situations. Extracting single
values via `std::get`, however, obeys regular value/reference syntax.

\code{.cc}
    auto it = range.begin();
    auto [i, d, s] = *it; // i, d, s are references
    i = 10; // modification of first entry of ints

    next = std::next(it); // advance STL-like
    auto another_i = std::get<0>(*next); // another_i is value

    i = std::get<0>(*next); // i is still reference
    i = 20; // modification of second entry of ints
\endcode

Zip iterators can be used in range-based and regular for loops. Additionally,
Utopia provides overloads for `ostream` std::operator<<() to write the contents
of a tuple into the command line. This works if the objects themselves can be
written into the same stream.

\code{.cc}
    #include <iostream>

    for (auto&& tuple : range) {
        std::cout << tuple << std::endl;
    }

    // equivalent explicit for loop without bindings:
    for (auto it = range.begin(); it != range.end(); ++it) {

        std::cout << "("
                  << std::get<0>(*it) << ", "
                  << std::get<1>(*it) << ", "
                  << std::get<2>(*it) << ")"
                  << std::endl;
    }
\endcode

Use the free function Utopia::adapt_zip() to build a ZipIterator from an
iterator adaptor and a set of containers.

\code{.cc}
    #include <iterator>

    auto range_in = Utopia::Itertools::zip(ints, doubles);
    std::vector<int> ints_out;
    std::vector<double> doubles_out;

    // create a ZipIterator that wraps back inserters
    auto it_out = Utopia::Itertools::zip_adapt(
        std::back_inserter,
        ints_out, doubles_out);

    std::transform(range_in.begin(), range_in.end(),
                   it_out,
                   [](auto&& tpl) {
                       auto [i, d] = tpl;
                       return std::make_tuple(i*i, d*d);
                   });
\endcode
\}



\defgroup TestTools Test Tools
\{
\ingroup Core
\brief   Gathers useful tools for writing tests in the Boost.Test framework

Have a look at the Utopia::TestTools namespace for more specific information.
\}

*/
